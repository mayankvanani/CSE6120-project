#!/usr/bin/env pythonimport networkx as nximport sysfrom random import sampleimport randomimport timeimport osimport mathimport numpy as npopt_cutoff = {'DATA/karate.graph':14, 'DATA/football.graph':94, 'DATA/jazz.graph':158, 'DATA/email.graph':594, 'DATA/delaunay_n10.graph':703,'DATA/netscience.graph':899, 'DATA/power.graph':2203,'DATA/as-22july06.graph':3303,'DATA/hep-th.graph':3926,'DATA/star2.graph':4542,'DATA/star.graph':6902}# Read in file to networkx graph structuredef read_graph(filename):    with open(filename, 'r') as f:        file = f.readlines()    for line_num, line in enumerate(file):        graph_data = list(map(lambda x: int(x), line.split()))        if line_num==0:            N = graph_data[0] # Number of Vertices            E = graph_data[1] # Number of Edges            G = nx.Graph()    # Graph object        else:            for adj_nodes in graph_data:                G.add_edge(line_num, adj_nodes)    return G,N,Edef isVC(VC, G):    if VC is None or G is None:        return False    for x in G.edges():        if (x[0] not in VC and x[1] not in VC):            return False    return True# Apply Local Search using Simulate Annealing Algorithmdef simulatedAnnealing(G, cutoff, trace_file, randSeed):    opt_answers = []    for i in range(50):        VC = G.copy()        nodes = list(G.nodes())        temp = 100.0   # Start temp        end_temp = 1.0 # End temp        alpha = 0.95  # Temp decrease ratio        _trace = []        start_time=time.time()        while(temp>end_temp and ((time.time()-start_time)<cutoff)):              temp = temp*alpha  # decrease temp every iteration            rand_node = np.random.choice(nodes)            #case1: If randomly selected node is in VC            if rand_node in VC.nodes():                 rand_node_edges = list(VC.edges(rand_node)) #saving the edges before deleting the node                VC.remove_node(rand_node)                if isVC(G,VC):                    _trace.append([time.time()-start_time, VC.number_of_nodes(), "case1"])                    continue                else:                    VC.add_edges_from(rand_node_edges) # adding back the node to VC            #Case2: If randomly selected node is NOT in VC            else:                VC.add_edges_from(list(G.edges(rand_node)))                p = math.exp( - (1+G.degree(rand_node) / temp))                rand_value_from_0_to_1 = random.uniform(0, 1)                print("p:",p,"  0to1:",rand_value_from_0_to_1)                if(p>rand_value_from_0_to_1):                    print("++++++++")                    _trace.append([time.time()-start_time, VC.number_of_nodes(), "case2"])                else:                    print("-----------")                    VC.remove_node(rand_node)                            if VC.number_of_nodes()<154:            break                                # Writing the .trace file    with open(trace_file, 'w') as f:        for t,n,c in _trace:            f.write(str(t) + ', ' + str(n) + ', ' + str(c) + '\n')     return VCdef main(graph_file, output_dir, cutoff, randSeed):    random.seed(randSeed)    solution_file = "Output/" + graph_file[5:-6] + "_LS2_" + str(int(cutoff)) + "_" + str(randSeed) + ".sol"    trace_file = "Output/" + graph_file[5:-6] + "_LS2_" + str(int(cutoff)) + "_" + str(randSeed) + ".trace"        G, N, E = read_graph(graph_file)    G1 = G.copy()        print("start!")    sol = simulatedAnnealing(G1, cutoff, trace_file, randSeed)        nodes = sorted(list(sol.nodes()))    node_size = len(list(sol.nodes()))    with open(solution_file,'w') as f:        f.write(str(node_size) + '\n')        for n in nodes:            f.write(str(n) + ',')    print("Completed!")if __name__ == '__main__':    graph_file = sys.argv[1]    cutoff = int(sys.argv[2])    output_dir = ''    randSeed = sys.argv[3]    main(graph_file, output_dir, cutoff, randSeed)